03/26/2022
Java Bootcamp Day01

Topics:
		1. Primitives: int, double, char, boolean
		2. Primitive Type Castings: Implicit vs Explicit
		3. Wrapper class
		4. String
		5. String vs StringBuilder vs StringBuffer
		6. Loops: for & while
		7. Array
		8. for each loop
		9. Custom Methods
		10. Method Overloading
		11. Constructor
		12. Class & Objects
		13. Static vs Instance
		14. Import Statements
		15. Access Modifiers
		16. OOP Encapsulations
		17. OOP Inheritance
		18. Method Overriding
		19. Final keyword
		20. OOP Abstraction
		21. Abstract Class vs Interface
		22. OOP Polymorphism
		23. Reference Type Castings: Upcasting vs DownCasting
		24. Exceptions: checked & unchecked
		25. Exception Handlings
		26. final vs finally vs finalize
		27. garbage collection & garbage collector
		28. Collections: List, Set, Queue
		29. Iteable & Iterator
		30. Maps


1. primitives:	int, double, char, boolean
		byte, short, int, long, float, double
		char, boolean


2. Primitive type castings
		
		1. implicit casting: casting smaller primitive type to larger (implicitly done)

		2. explicit casting: casting larger primitive type to smaller (explicitly done)


3. Wrapper classes: the objects that represents the primitives


4. String: immutable version char sequence
		
		"Java "
		 01234

		 Methods: charAt, length, trim, lowercase & uppercase, replace, substring, equals, contains, split, tochararray


5. StringBuilder vs StringBuffer: mutable char sequence

		StringBuilder: not Synchronized

		StringBuffer: Synchronized



6. Loops: repeated action

	for loop:
		for(initialization; Condition; Iterator ){
			statements
		}


	while loop:

		while(Condition){
			statements
		}


7. Array: supports both primitives & non-primitives
		  size is fixed
		  can be multi-dimensional: n dimensional array contains (n-1) dimensional arrays
		  has index


8. For Each Loop: There must be a data structure 
				 Iteration order is fixed


			for(DataType var  : Data Structure ){

			}


9. Custom method: Function
				 grouping a series of code fragments

				 improves the reusability of the codes


			 declare: 
			 	 Access-Modifier  Specifier   ReturnType  methodName(Parameter){

			 	 } 

			 	 Access Modifier: public, protected, default, private
			 	 Specifier: static, final, abstract, synchronized
			 	 Return Type: void, DataType
			 	 Parameter: DataType
			 	 methodName: any name



10. Method overloading: multiple methods sharing the same method name
						parameters must be different

						happens in same class
						return type, access mdoifeirs can be same or different


11. Constructor: special method, every class MUST have it
				 used for creating objects from the class
				 execution depends on the object


			 declare:
			 		Access_Modifier  ClassName(parameter){

			 		}


		Creating Object:
				new Constructor;


		in my framework:
				BasePage:
					public BasePage(){
						Pagefactory.initElements(driver, this)
					}


				@FindBy

come back at: 1:10 pm US EST





